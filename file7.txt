Global Interpreter Lock (GIL)
Потоки можуть виконуватися дійсно паралельно (якщо ядер процесора більше, ніж 1), процеси — тим більше. Але у Python є механізм, який примусово блокує виконання коду
різними потоками одного Python процесу в один і той самий час.
1. Тільки один потік всередині процесу Python виконується, усі інші (якщо такі є) знаходяться в режимі 'Sleep'.
2. Потоки у Python можуть здійснювати I/O операції одночасно, тому що GIL не блокує їх під час очікування на системні виклики. Проте коли справа доходить до виконання Python коду, 
GIL дозволяє тільки одному потоку керувати інтерпретатором у будь-який момент часу.
Це означає, що якщо ви зробите кілька IO викликів у різних потоках, то вам не гарантується черговість завершення цих потоків, але гарантується, що коли виконується код будь-якого з потоків, 
усі інші потоки чекають черги й нічого не роблять. Це буде так, навіть якщо код виконується на сучасному процесорі з кількома ядрами.
Чому в Python є GIL?
1. Простий і зрозумілий збирач сміття.
2. Виключає можливість одночасного доступу до ресурсів/пам'яті. Немає потреби враховувати особливості конкретної ОС для обробки таких ситуацій.
3. Це спадщина епохи одноядерних процесорів, коли додаткові потоки/процеси уповільнювали виконання програми.
Python розроблявся в епоху одноядерних процесорів, і навіть теоретично ніхто тоді не міг припустити дійсне одночасне виконання коду в різних потоках. Через це було зроблено низку архітектурних рішень,
які вже не змінити, і на Python накладено обмеження GIL.
Як обійти GIL:
1. Написати частину коду, яку потрібно запускати паралельно, на Рython і використовувати потоки.
2. Використовувати Multiprocessing.
Чому не потрібно цього робити:
1. Python — скриптова мова і швидкість роботи — не її сильна сторона. Якщо потрібна швидкість, то, можливо, є сенс розглянути інший інструмент.
2. Створення процесів використовує деяку кількість ресурсів системи (пам'ять і процесорний час).
3. Перемикання між процесами також використовує процесорний час.