Синхронізація потоків
Синхронізація потоків у Python — це процес координації виконання кількох потоків у програмі, щоб забезпечити, що вони не порушують взаємозв’язки даних чи не створюють непередбачувані 
результати при одночасному доступі до спільних ресурсів. У Python для управління доступом до спільних ресурсів часто використовуються блокування (locks) та семафори (semaphores), про які ми 
вже говорили.
Також існують умовні перемикачі (condition variables), бар'єри (barriers) та події (events), які ми детально розглянемо в нашому подальшому обговоренні.
Condition
Є примітиви синхронізації, які дозволяють потокам очікувати сигнал від інших потоків — це Condition. Створимо дві різні функції: одна master повідомлятиме, що worker може продовжити роботу. 
При цьому вони будуть виконуватись у різних потоках.
Спочатку master у потоці виконує якусь роботу. Після цього він виконує метод condition.notify_all(), чим дозволяє запустити інші потоки, доки вони чекають виконання. Вони очікують на виконання 
в точці виклику методу condition.wait().
Після виконання коду прикладу у консолі ви побачите:
Якщо ж master повинен дозволити роботу лише одному з worker, можна викликати метод condition.notify(), тоді тільки один з тих, хто очікує дозволу worker, продовжить роботу.
 Другий чекатиме, доки не буде виконано наступне condition.notify.
Event
Інший примітив синхронізації — це потокобезпечний прапорець класу Event. Клас Event має внутрішній прапорець, який можуть встановлювати або скидати інші потоки. 
Для цього використовують метод set, щоб встановити прапор та метод clear для скидання. Метод wait класу Event зупиняє роботу потоку до того часу, доки інший потік не встановить прапор методом set. 
Є можливість перевірити, чи встановлено прапор методом is_set.
Таким чином, master може встановити прапорець класу Event, і всі worker потоки продовжать роботу тільки після отримання дозволу.
Виникає закономірне питання — навіщо, якщо результат той самий? Справа в тому, що ми можемо керувати виконанням, перезапуском і зупинкою роботи потоків через клас Event. 
Наприклад, у наступному прикладі ми перериваємо виконання потоку, який працює в нескінченному циклі та інакше просто ніколи не завершиться.
Останній примітив синхронізації, який ми розглянемо в Python — це бар'єр Barrier. Він дозволяє задати умову, щоб кілька потоків продовжили роботу лише після того, 
як задане число потоків добереться у виконанні коду до цього "бар'єру".
Використовується, коли вам потрібно, щоб робота застосунку продовжилася лише після того, як усі потоки зроблять якусь частину своєї роботи та дійдуть до деякої точки, 
з якою можна знову продовжувати.
Розглянемо наступний приклад:
Потік може дістатися бар'єру і чекати його за допомогою функції wait(). Це блокуючий виклик, який повернеться, коли решта потоків (попередньо налаштована кількість barrier = Barrier(5))
 дістанеться бар'єру.
Функція очікування wait() повертає ціле число, яка вказує на кількість учасників, що залишилися до бар'єру. Якщо потік був останнім, що прибув, то повернене значення буде нульовим.
Як бачимо в нашому прикладі, спочатку виконалися потоки