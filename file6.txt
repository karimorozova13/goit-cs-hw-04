IO and CPU-bound tasks
Завдання, які виконують операції введення/виведення (читання/запис файлів, запити в мережі тощо), називаються IO (Input Output)-bound завданнями. Домогтися паралелізму виконання IO завдань у 
Python можна, використовуючи потоки.
Однак потрібно пам'ятати, що асинхронний код завжди значно складніший для розуміння та відлагодження. Для багатопотокових застосунків складно писати тести та перевіряти всілякі ситуації, 
які відбуваються рідко та залежать від порядку викликів у різних потоках. Загальне правило для програмування будь-якою мовою: якщо є можливість обійтися синхронним кодом, то так і потрібно зробити.
Інший тип блокуючих викликів — це важкі з точки зору обчислень операції. Реальний застосунок завжди повинен якимось чином реагувати на дії користувача і якщо ваш застосунок під час виконання 
складних обчислень перестає відповідати на запити, то користувач може вирішити, що застосунок просто завис. Виходить, що для зручності користувача застосунок повинен відповідати на запити, 
навіть коли робить якісь складні та довгі обчислення.
Такі завдання називаються CPU-bound завданнями. Як і для IO-bound завдань, можна винести виконання блокуючих операцій (складних обчислень) в окремий потік, щоб застосунок продовжував взаємодіяти 
з користувачем, здійснюючи обчислення.
Загалом операційна система передає управління потокам (як і передача управління процесами). Це означає, що будь-якої миті перед будь-яким викликом ОС (Операційна Система)
може призупинити виконання коду потоку та розпочати виконувати код іншого потоку, щоб потім так само далі призупинити і його для передачі управління.
До появи багатоядерних процесорів справжній паралелізм був неможливим. Звичайно, коли управління передається різним потокам по кілька тисяч разів на секунду, 
з погляду користувача це виглядає як паралельне виконання кількох завдань. У сучасних процесорах зазвичай є мінімум два ядра і тепер ми можемо писати код, який виконується справді паралельно. 
Це, з одного боку, додає можливостей, але й додає складнощів, оскільки тепер потрібно бути ще уважнішими при написанні асинхронного коду, адже припуститися помилки ще простіше.
Радимо ознайомитися з гарною статтею про асинхронний код.