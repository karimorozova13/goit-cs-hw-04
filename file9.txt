Контроль доступу до ресурсів
Оскільки ОС може на будь-якому виклику перервати виконання потоку та передати контроль іншому потоку, ви не можете бути впевненим/-ою, що робота із загальним ресурсом буде коректно завершеною 
і ресурс не опиниться в невизначеному стані.
М'ютекси
М'ютекси — це один із фундаментальних механізмів синхронізації в багатопотоковому програмуванні та операційних системах для управління доступом до спільних ресурсів.
М'ютекс діє як «ключ» до ресурсу, який можуть використовувати потоки програми або процеси для гарантування взаємного виключення, тобто в будь-який момент часу тільки один 
потік може мати доступ до критичної секції коду, що взаємодіє зі спільним ресурсом.
У Python м'ютекси зазвичай використовуються в контексті багатопотокового програмування, але через особливості GIL (Global Interpreter Lock), який уже діє як своєрідний м'ютекс на 
рівні інтерпретатора, м'ютекси в основному використовуються для управління доступом до спільних ресурсів, а не для забезпечення одночасного виконання коду на багатоядерних системах.
У Python м'ютекси можна реалізувати за допомогою модуля threading. У Python є два примітиви блокувань: Lock і RLock. Lock трохи швидший і більш низькорівневий, але він не рекурсивний 
і може бути ситуація потрапляння в DeadLock, коли виконання коду заблокується, кілька потоків чекатимуть, доки хтось віддасть Lock, а його ніхто ніколи вже не віддасть. Це і є ситуація, 
коли програма "зависла".
RLock трохи повільніший, зате виключає взаємне блокування. Рекомендується завжди використовувати саме його, якщо немає вагомих причин використовувати Lock.
Якщо провести аналогію з життя, то Lock — це коли у кожного потоку один і той самий ключ і будь-який потік може відкрити замок, хто б його не закрив із потоків. З RLock ситуація трохи інша,
 у кожного потоку свій ключ і свій замок. Потік може відкрити лише свій замок своїм ключем і не відкриє замок, якщо його закрив інший потік.
У цьому прикладі ми запустили два потоки і один загальний RLock. У консолі ви побачите:
Таке виведення означає, що один із потоків "взяв" lock, і поки він його не "відпустив", інший чекав, доки lock звільниться. Блокування ресурсу досягається виконанням команди locker.acquire(). 
Це робиться, щоб загальним ресурсом міг користуватися лише один потік на один момент часу, і лише коли потік закінчить роботу із загальним ресурсом, він відпускає lock, у нашому випадку — 
команда locker.release(), і хтось інший зможе попрацювати з ресурсом. 
Так гарантується, що загальний ресурс не потрапить у невизначений стан, коли хтось почав із ним роботу та не закінчив, а хтось інший почав, і так далі.
Але найчастіше для блокування використовують контекст виконання:
Семафори
Другий примітив синхронізації — це семафори.
Семафори підходять до блокування іншим шляхом та вказують, що кілька потоків можуть користуватися ресурсом одночасно і цим обмежують кількість потоків.
Наприклад, ми не хочемо надсилати десятки тисяч запитів до мережі одночасно, щоб не створювати навантаження на обладнання, і вкажемо семафор, щоб не більше ста потоків могли одночасно надсилати запити.
 Щойно якийсь із потоків закінчить роботу і семафор його відпустить, то наступний потік із черги очікування зможе зробити свій запит.
Як приклад розглянемо виконання 10 потоків і обмежимо виконання за допомогою семафору до двох одночасно:
Результат у вас може відрізнятися, це справа випадку, коли і який потік візьме семафор. Але суть буде та сама, один потік чекатиме своєї черги, доки семафор звільниться. 
Окрім того, якщо потоки одночасно почнуть писати в консоль, їх виведення може перемішатися і матиме вигляд, начебто дві людини одночасно намагаються набрати повідомлення на одній клавіатурі.